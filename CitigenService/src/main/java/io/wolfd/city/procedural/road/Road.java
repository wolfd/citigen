/**
 *
 */
package io.wolfd.city.procedural.road;

import io.wolfd.city.procedural.Node;
import io.wolfd.city.procedural.util.HasPriority;
import io.wolfd.city.server.data.RoadData;
import io.wolfd.city.server.data.WebVector3;
import mikera.vectorz.Vector3;

/**
 * SmartRoad contains the data relating to the patterns of a road. Contains
 * methods for creating new roads and mixing patterns.
 *
 * @author Daniel Wolf <wolf@ccs.neu.edu>
 * @version Jan 21, 2014
 */
public class Road implements HasPriority {
  /**
   * Starting node
   */
  public final Node a;
  /**
   * Ending node
   */
  public final Node b;
  /**
   * Includes a list of patterns to use, operates a palate
   */
  private PatternLibrary patterns;
  /**
   * Filter to apply to roads generated by this road Alternatively: applied to
   * this road, and
   */
  private FilterLibrary filters;
  public boolean failed;

  private Road(Node a, Node b, PatternLibrary patterns, FilterLibrary filters) {
    this.a = a;
    this.b = b;
    this.patterns = patterns;
    this.filters = filters;
    this.failed = false;
  }

  public static Road seed(Vector3 start, double angle, PatternLibrary patterns, FilterLibrary filters) {
    Node startNode = new Node(start);

    Vector3 end = new Vector3(Math.cos(angle), Math.sin(angle), 0);
    end.multiply(20);
    Node endNode = new Node(end);

    Road seedRoad = new Road(startNode, endNode, patterns, filters);

    startNode.addRoad(seedRoad);
    endNode.addRoad(seedRoad);

    return seedRoad;
  }

  public static Road create(Road parent, RoadPattern.Direction direction) {
    return parent.create(direction);
  }

  /**
   * Create the next iteration using the PatternLibrary and the RoadFilter.
   *
   * @param direction
   * @return
   */
  private Road create(RoadPattern.Direction direction) {
    Vector3 end = patterns.generate(this, direction);
    PatternLibrary newLibrary = patterns.mutate();
    Road newRoad = new Road(
        this.b,
        new Node(end),
        newLibrary,
        filters
    );
    this.b.addRoad(newRoad);
    newRoad.b.addRoad(newRoad);
    return newRoad;
  }

  public Road filter() {
    return filters.filter(this);
  }

  /**
   * Remove all references to this road from connected nodes' lists
   */
  public void remove() {
    a.getRoads().remove(this);
    b.getRoads().remove(this);
  }

  /**
   * the weight of the item in the queue {-1} U [0 to 1]. 0 being
   * least important, and 1 being most important. -1 meaning
   * automatic placement on the top of the queue.
   *
   * @return priority
   */
  public double getPriority() {
    return this.patterns.getPriority();
  }

  /*
   * (non-Javadoc)
   * @see java.lang.Object#equals(java.lang.Object)
   */
  @Override public boolean equals(Object o) {
    if (o instanceof Road) {
      return (this.a.equals(((Road) o).a) && this.b.equals(((Road) o).b))
          || (this.b.equals(((Road) o).a) && this.a
          .equals(((Road) o).b));
    } else {
      return false;
    }
  }

  @Override public String toString() {
    return "Road{" +
        "a=" + a +
        ", b=" + b +
        '}';
  }

  public RoadRectangle getRoadRectangle() {
    return new RoadRectangle(a.getPosition(), b.getPosition(), 5);
  }

  public RoadData toPOJO() {
    return new RoadData(new WebVector3(a.getPosition()), new WebVector3(b.getPosition()));
  }
}
